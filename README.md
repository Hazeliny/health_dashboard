# Patient Dashboard Project

## Project Overview
This project is a web application designed to display patient details and visual sensor data, sourced from both static mock data provided by DummyJSON and real-time mock data generated by a custom backend API I developed.

The demos are presented as follows:

- Demo of the deployed app on Azure:

![AZUREPATIENTDASHBOARD](https://github.com/Hazeliny/patient_dashboard/blob/main/patient-dashboard/src/assets/Azure_Pro_Patient_Dashboard.gif)

- Demo of local developed app:

![LOCALPATIENTDASHBOARD](https://github.com/Hazeliny/health_dashboard/blob/main/patient-dashboard/src/assets/Local_Dev_PatientDashboard-improv3.gif)


## How to Run Locally

### 1. Git clone the code

```
git clone git@github.com:Hazeliny/patient_dashboard.git projectName

cd projectName
```

### 2. Install Node.js+React+Vite

If Node.js (with npm) is not already installed, please download and install it from the official website.

There is no need to install React and Vite separately, as the package.json file already includes all required dependencies, which will be installed in Step 3.

The following command is used to initialize a new frontend project:

```
npm create vite@latest projectName -- --template react
```

### 3. Install dependencies

```
cd projectName
npm install
```

### 4. Run both frontend and backend locally

```
cd mock-sensor-server
npm install
node mock-sensor-server.js

cd patient-dashboard
npm run dev
```

### 5. Open the frontend

This application runs at default port 5173. 

```
http://localhost:5173
```


## How to View the Deployed App on Azure

- Frontend (**Patient Dashboard Frontend**): [https://purple-ocean-00d49ed10.6.azurestaticapps.net](https://purple-ocean-00d49ed10.6.azurestaticapps.net)

- Backend (**WebSocket Mock Sensor Server**): [https://mock-sensor-server-app.azurewebsites.net](https://mock-sensor-server-app.azurewebsites.net)


## Technologies stack

- React + Vite + SPA

- JavaScript / HTML / JSX / JSON

- WebSockets

- Tailwind CSS (Visulaization / Interactive Graphical UI)

- Chart.js + react-chartjs-2 + react-d3-speedometer + chartjs-plugin-zoom + chartjs-adapter-date-fns 

- Responsive design

- Node.js + Express + RESTful API (backend API for simulating sensors to generate real-time medical data)

- Cloud deployment (Azure)


## Features

1. The main page displays a **list of patients**, which is fetched from the static JSON API at https://dummyjson.com/users.

2. When a user clicks on a patient's name in the list, the application shows the **patient's details** along with **two tabs**: **Summary and Chart**.

    a) The **patient details** are fetched based on their ID from the static JSON API at https://dummyjson.com/users.

    b) The **Summary and Chart** information is retrieved from a static mock API hosted at https://dummyjson.com/custom-response (e.g., https://dummyjson.com/c/cc06-e16f-4842-bdc6), either by default or when the "**Static Data**" radio button is selected.

    c) When the "**Real-Time Data**" radio button is selected, real-time sensor data is streamed to the frontend via **WebSocket** from a custom backend API (mock-sensor-server). This server simulates real medical sensors by generating and pushing random data to the client every 3 seconds.

3. Sensor data is visualized using **interactive graphics** powered by Chart.js **bar charts** and **speedometer gauge**. The dashboard displays six **graph cards**, each representing a medical index.

    a) Each bar's color indicates the data's status based on a **legend**:

    - Blue for normal values

    - Red for values above normal

    - Yellow for values below normal

    b) **Colored alert lines** are drawn using chartjs-plugin-annotation:

    - Red line marks the upper threshold

    - Yellow line marks the lower threshold

    c) A **tooltip** displaying additional info appears when hovering over a bar.

    d) Each metric card containing a bar chart features the following **interactive behavior**:

    - **Hover Effect**: When the user hovers over a card, a blue border appears around it to indicate it's clickable.

    - **Tooltip Prompt**: While hovering, a tooltip near the cursor displays the message: "Click to view visual monitor" to guide the user.

    - **Click Action**: Upon clicking anywhere on the card, a colorful **gauge-style monitor** slides in from the left side of the screen.

    - **Visual Monitor Panel**: This side panel presents a dynamic visual representation of the selected metric, complete with numeric values and colored indicators for easy interpretation.

    e) **Historical Trend Line Chart Panel** visualizes the historical trend of a specific medical metric for a selected patient over a user-defined time range:

    - 24 hours (default)

    - 7 days

    - 1 month

    By clicking the **line chart icon** in the top-right corner of any metric card, users can open a sliding panel from the right that displays the corresponding trend line chart.

    Within this panel, users can interact with the chart using mouse-based **zooming**, **panning**, and view **tooltips** for detailed data points.

    ðŸ”„ **Backend Data Generation and Storage and management**: The backend simulates real-time sensor readings by generating random medical values **every 3 seconds**, and inserts them into a **MongoDB** database. The system assumes one data record is produced **every 2 hours**, meaning:

    - 12 records for the past 24 hours - displays 12 points

    - 84 records for the past 7 days - displays 12 points, each representing the average of 7 data points

    - 360 records for the past month - displays 12 points, each representing the average of 30 data points

    The MongoDB collection is capped to store a maximum of 360 records, adhering to a **First-In-First-Out (FIFO)** policy to simulate continuous, real-time data updates, where the oldest data is automatically overwritten as new data arrives.

    ðŸ”— **Frontend Integration**: The frontend fetches data from the backend via a **RESTful API** to render the line chart dynamically based on the selected time range and metric. And the front end also handle the **aggregation** for the 7 days and the past month data.

4. The frontend is built with **React + Vite + SPA**.

5. **TailwindCSS** is used for implementing a **modern**, **responsive web interface**.

6. **WebSocket** enables **real-time** data transmission from the backend to the frontend.

7. The application is deployed on **Microsoft Azure**.

8. The project is built as a **Single Page Application (SPA)** to support partial rerendering and dynamic data loading, ensuring a smooth user experience.


## Challenges

- Integrating WebSocket for real-time data and RESTful API implementation and data design.

- Deploying frontend and backend to Azure.

- Designing modern and interactive data visualization charts.


## Future Improvements and Technical Reflections

This project serves as a foundation for a static/real-time health monitoring dashboard. Looking forward, several meaningful enhancements can be made:

- **CI/CD Optimization**: Integrate full GitHub Actions workflows for backend as well, including automated testing and deployment to Azure App Service with rollback strategies.
- **AI Integration**: Incorporate AI-based anomaly detection on sensor data to alert healthcare providers when unusual patterns are detected (e.g., abnormal heart rate or blood oxygen).
- **Real Production Data**: Replace the mock WebSocket server with real sensor APIs or a secure data ingestion pipeline (e.g., using Azure IoT Hub or Event Hubs).
- **Scalability**: Containerize backend with Docker and deploy to Azure Kubernetes Service (AKS) for better scalability and microservice architecture potential.
- **Security Enhancements**: Add authentication (e.g., Azure AD B2C) and rate-limiting on WebSocket endpoints to prevent abuse in production.
- **Offline Mode**: Add service worker support for offline-first capabilities, especially useful in medical field operations with intermittent connectivity.

These ideas aim to make the solution more robust, intelligent, and enterprise-ready.
